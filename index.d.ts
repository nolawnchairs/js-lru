// Generated by dts-bundle-generator v5.9.0

/**
 * Implementation of the ES6 Map interface that maintains a LRU
 * (least recently used) ordering to its entries that are mutated
 * with the get and set methods
 *
 * @export
 * @class LRUMap
 * @template K the type of the map keys, constrained to string, number or symbol
 * @template V the type of the map values
 */
export declare class LRUMap<K extends KeyScalar, V> {
	private readonly capacity;
	private items;
	private frames;
	/**
	 * Creates an instance of LRUMap.
	 *
	 * @param {number} capacity the maximum number of entries to hold
	 * @param {Iterable<[K, V]>} [entries] optional iterable of key-value tuples to initiate the map. LRU ordering is applied immediately to initial entries
	 * @memberof LRUMap
	 */
	constructor(capacity: number, entries?: Iterable<[
		K,
		V
	]>);
	/**
	 * Creates an unbounded LURMap instance that can hold an
	 * infinite number of entries
	 *
	 * @static
	 * @template K the type of the map keys, constrained to string, number or symbol
	 * @template V the type of the map values
	 * @param {Iterable<[K, V]>} [entries] optional iterable of key-value tuples to initiate the map. LRU ordering is applied immediately to initial entries
	 * @return {*}  {LRUMap<K,V>}
	 * @memberof LRUMap
	 */
	static unbounded<K extends KeyScalar, V>(entries?: Iterable<[
		K,
		V
	]>): LRUMap<K, V>;
	/**
	 * Gets the size of the collection
	 *
	 * @readonly
	 * @type {number}
	 * @memberof LRUMap
	 */
	get size(): number;
	/**
	 * Gets an entry value from the map and registers recent use
	 *
	 * @param {K} key the key
	 * @return {*}  {Nullable<V>} the value, which could be null
	 * @memberof LRUMap
	 */
	get(key: K): Nullable<V>;
	/**
	 * Peeks at an entry value without registering recent use
	 *
	 * @param {K} key the key
	 * @return {*}  {Nullable<V>} the value which could be null
	 * @memberof LRUMap
	 */
	peek(key: K): Nullable<V>;
	/**
	 * Sets or replaces an entry in the map with key and
	 * registers recent use
	 *
	 * @param {K} key the key
	 * @param {V} value the value
	 * @memberof LRUMap
	 */
	set(key: K, value: V): this;
	/**
	 * Removes an entry from the map and returns the removed entry's value
	 *
	 * @param {K} key the key
	 * @return {*}  {Nullable<V>} the removed item, which could be null
	 * @memberof LRUMap
	 */
	remove(key: K): Nullable<V>;
	/**
	 * Removes an entry from the map
	 *
	 * @param {K} key
	 * @return {*}  {boolean}
	 * @memberof LRUMap
	 */
	delete(key: K): boolean;
	/**
	 * The oldest entry in the map (access foes not register recent use)
	 *
	 * @return {*}  {MapEntry<K, V>} the entry
	 * @memberof LRUMap
	 */
	get tail(): MapEntry<K, V>;
	/**
	 * The newest entry in the map (access foes not register recent use)
	 *
	 * @return {*}  {MapEntry<K, V>} the entry
	 * @memberof LRUMap
	 */
	get head(): MapEntry<K, V>;
	/**
	 * Check if a key is present in the map
	 *
	 * @param {K} key
	 * @return {*}  {boolean}
	 * @memberof LRUMap
	 */
	has(key: K): boolean;
	/**
	 * Clears all entries from the map
	 *
	 * @memberof LRUMap
	 */
	clear(): void;
	/**
	 * Iterates over each entry and applies a callback function to each
	 * entry without registering recent uses
	 *
	 * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
	 * @param {*} [thisArg]
	 * @memberof LRUMap
	 */
	forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
	/**
	 * Iterates over all entries in the map without
	 * registering recent uses
	 *
	 * @memberof LRUMap
	 */
	[Symbol.iterator](): Generator<[
		K,
		V
	], void, unknown>;
	/**
	 * Get an iterator of all map entries in tuple form without registering
	 * recent uses
	 *
	 * @return {*}  {IterableIterator<[K, V]>}
	 * @memberof LRUMap
	 */
	entries(): IterableIterator<[
		K,
		V
	]>;
	/**
	 * Gets an iterator of all map entries without registering recent uses
	 *
	 * @return {*}  {IterableIterator<MapEntry<K, V>>}
	 * @memberof LRUMap
	 */
	entryIterator(): IterableIterator<MapEntry<K, V>>;
	/**
	 * Get an iterator of all entry keys without registering any
	 * recent uses
	 *
	 * @return {*}  {IterableIterator<K>}
	 * @memberof LRUMap
	 */
	keys(): IterableIterator<K>;
	/**
	 * Get an iterator of all entry values without registering any
	 * recent uses
	 *
	 * @return {*}  {IterableIterator<V>}
	 * @memberof LRUMap
	 */
	values(): IterableIterator<V>;
	/**
	 * Converts the map to an array of entry values, returned in the
	 * order of least recently used items first. Does not register any
	 * recent uses
	 *
	 * @return {*}  {V[]}
	 * @memberof LRUMap
	 */
	toArray(): V[];
	/**
	 * Removes an item from the frame index and
	 * reorders the indexing
	 *
	 * @private
	 * @param {K} key
	 * @memberof LRUMap
	 */
	private dropFrame;
	/**
	 * Promotes a key to first frame index and
	 * reorders the indexing
	 *
	 * @private
	 * @param {K} key
	 * @memberof LRUMap
	 */
	private promoteFrame;
	/**
	 * Evict all oldest references that do not fit into the capacity
	 *
	 * @private
	 * @memberof LRUMap
	 */
	private evictOverflow;
	/**
	 * Returns a string representation of the map
	 *
	 * @return {*} string
	 * @memberof LRUMap
	 */
	toString(): string;
}
export declare type KeyScalar = string | number | symbol;
export declare type Nullable<T> = T;
export interface MapEntry<K, V> {
	key: K;
	value: V;
}

export as namespace MyModuleName;

export {};
